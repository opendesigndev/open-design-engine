
// Generated by json-cpp-gen by Viktor Chlumsky
// https://github.com/Chlumsky/json-cpp-gen

#include "AnimationSerializer.h"

#ifndef JSON_CPP_SERIALIZE_DOUBLE
#include <cstdio>
#define JSON_CPP_SERIALIZE_DOUBLE(outBuffer, x) sprintf(outBuffer, "%.17g", x)
#endif

namespace ode {

AnimationSerializer::Error::operator AnimationSerializer::Error::Type() const {
    return type;
}

AnimationSerializer::Error::operator bool() const {
    return type != Error::OK;
}

const char *AnimationSerializer::Error::typeString() const {
    switch (type) {
        case Error::OK:
            return "OK";
        case Error::UNREPRESENTABLE_FLOAT_VALUE:
            return "UNREPRESENTABLE_FLOAT_VALUE";
        case Error::UNKNOWN_ENUM_VALUE:
            return "UNKNOWN_ENUM_VALUE";
    }
    return "";
}

AnimationSerializer::AnimationSerializer(std::string &json) : json(json) {
    json.clear();
}

void AnimationSerializer::write(char c) {
    json.push_back(c);
}

void AnimationSerializer::write(const char *str) {
    json += str;
}

void AnimationSerializer::writeEscaped(char c) {
    switch (c) {
        case '\x00': write("\\u0000"); break;
        case '\x01': write("\\u0001"); break;
        case '\x02': write("\\u0002"); break;
        case '\x03': write("\\u0003"); break;
        case '\x04': write("\\u0004"); break;
        case '\x05': write("\\u0005"); break;
        case '\x06': write("\\u0006"); break;
        case '\x07': write("\\u0007"); break;
        case '\b': write("\\b"); break;
        case '\t': write("\\t"); break;
        case '\n': write("\\n"); break;
        case '\x0b': write("\\u000b"); break;
        case '\f': write("\\f"); break;
        case '\r': write("\\r"); break;
        case '\x0e': write("\\u000e"); break;
        case '\x0f': write("\\u000f"); break;
        case '\x10': write("\\u0010"); break;
        case '\x11': write("\\u0011"); break;
        case '\x12': write("\\u0012"); break;
        case '\x13': write("\\u0013"); break;
        case '\x14': write("\\u0014"); break;
        case '\x15': write("\\u0015"); break;
        case '\x16': write("\\u0016"); break;
        case '\x17': write("\\u0017"); break;
        case '\x18': write("\\u0018"); break;
        case '\x19': write("\\u0019"); break;
        case '\x1a': write("\\u001a"); break;
        case '\x1b': write("\\u001b"); break;
        case '\x1c': write("\\u001c"); break;
        case '\x1d': write("\\u001d"); break;
        case '\x1e': write("\\u001e"); break;
        case '\x1f': write("\\u001f"); break;
        case '"': write("\\\""); break;
        case '\\': write("\\\\"); break;
        default:
            write(c);
    }
}

AnimationSerializer::Error AnimationSerializer::serialize(std::string &jsonString, ode::DocumentAnimation const &input) {
    return AnimationSerializer(jsonString).serializeOdeDocumentAnimation(input);
}

AnimationSerializer::Error AnimationSerializer::serializeStdString(std::string const &value) {
    write('"');
    for (char c : value) { writeEscaped(c); }
    write('"');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeOdeLayerAnimationType(ode::LayerAnimation::Type const &value) {
    switch (value) {
        case ode::LayerAnimation::TRANSFORM: write("\"TRANSFORM\""); break;
        case ode::LayerAnimation::ROTATION: write("\"ROTATION\""); break;
        case ode::LayerAnimation::OPACITY: write("\"OPACITY\""); break;
        case ode::LayerAnimation::FILL_COLOR: write("\"FILL_COLOR\""); break;
        default:
            return Error(Error::UNKNOWN_ENUM_VALUE, &value);
    }
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeDouble(double const &value) {
    char buffer[64];
    JSON_CPP_SERIALIZE_DOUBLE(buffer, value);
    switch (buffer[1]) {
        case 'i':
            write("-1e999");
            break;
        case 'n':
            if (buffer[0] == 'i') {
                write("1e999");
                break;
            }
            // fallthrough
        case 'a':
            return Error(Error::UNREPRESENTABLE_FLOAT_VALUE, &value);
            break;
        default:
            write(buffer);
    }
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeStdVectorDouble(std::vector<double> const &value) {
    bool prev = false;
    write('[');
    for (double const &elem : value) { if (prev) write(','); prev = true; if (Error error = serializeDouble(elem)) return error; }
    write(']');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeStdArrayDouble6(std::array<double, 6> const &value) {
    write('[');
    if (Error error = serializeDouble(value[0]))
        return error;
    for (int i = 1; i < 6; ++i) {
        write(',');
        if (Error error = serializeDouble(value[i]))
            return error;
    }
    write(']');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeOctopusColor(octopus::Color const &value) {
    write("{\"" "r" "\":");
    if (Error error = serializeDouble(value.r))
        return error;
    write(",\"" "g" "\":");
    if (Error error = serializeDouble(value.g))
        return error;
    write(",\"" "b" "\":");
    if (Error error = serializeDouble(value.b))
        return error;
    write(",\"" "a" "\":");
    if (Error error = serializeDouble(value.a))
        return error;
    write('}');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeOdeLayerAnimationKeyframe(ode::LayerAnimation::Keyframe const &value) {
    write("{\"" "delay" "\":");
    if (Error error = serializeDouble(value.delay))
        return error;
    if (value.easing.has_value()) {
        write(",\"" "easing" "\":");
        if (Error error = serializeStdVectorDouble(value.easing.value()))
            return error;
    }
    if (value.transform.has_value()) {
        write(",\"" "transform" "\":");
        if (Error error = serializeStdArrayDouble6(value.transform.value()))
            return error;
    }
    if (value.rotation.has_value()) {
        write(",\"" "rotation" "\":");
        if (Error error = serializeDouble(value.rotation.value()))
            return error;
    }
    if (value.opacity.has_value()) {
        write(",\"" "opacity" "\":");
        if (Error error = serializeDouble(value.opacity.value()))
            return error;
    }
    if (value.color.has_value()) {
        write(",\"" "color" "\":");
        if (Error error = serializeOctopusColor(value.color.value()))
            return error;
    }
    write('}');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeStdVectorOdeLayerAnimationKeyframe(std::vector<ode::LayerAnimation::Keyframe> const &value) {
    bool prev = false;
    write('[');
    for (ode::LayerAnimation::Keyframe const &elem : value) { if (prev) write(','); prev = true; if (Error error = serializeOdeLayerAnimationKeyframe(elem)) return error; }
    write(']');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeStdArrayDouble2(std::array<double, 2> const &value) {
    write('[');
    if (Error error = serializeDouble(value[0]))
        return error;
    for (int i = 1; i < 2; ++i) {
        write(',');
        if (Error error = serializeDouble(value[i]))
            return error;
    }
    write(']');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeOdeLayerAnimation(ode::LayerAnimation const &value) {
    write("{\"" "layer" "\":");
    if (Error error = serializeStdString(value.layer))
        return error;
    write(",\"" "type" "\":");
    if (Error error = serializeOdeLayerAnimationType(value.type))
        return error;
    write(",\"" "keyframes" "\":");
    if (Error error = serializeStdVectorOdeLayerAnimationKeyframe(value.keyframes))
        return error;
    if (value.rotationCenter.has_value()) {
        write(",\"" "rotationCenter" "\":");
        if (Error error = serializeStdArrayDouble2(value.rotationCenter.value()))
            return error;
    }
    write('}');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeStdVectorOdeLayerAnimation(std::vector<ode::LayerAnimation> const &value) {
    bool prev = false;
    write('[');
    for (ode::LayerAnimation const &elem : value) { if (prev) write(','); prev = true; if (Error error = serializeOdeLayerAnimation(elem)) return error; }
    write(']');
    return Error::OK;
}

AnimationSerializer::Error AnimationSerializer::serializeOdeDocumentAnimation(ode::DocumentAnimation const &value) {
    write("{\"" "animations" "\":");
    if (Error error = serializeStdVectorOdeLayerAnimation(value.animations))
        return error;
    write('}');
    return Error::OK;
}

}
