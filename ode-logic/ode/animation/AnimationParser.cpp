
// Generated by json-cpp-gen by Viktor Chlumsky
// https://github.com/Chlumsky/json-cpp-gen

#include <cstdlib>
#include "AnimationParser.h"

namespace ode {

AnimationParser::Error::operator AnimationParser::Error::Type() const {
    return type;
}

AnimationParser::Error::operator bool() const {
    return type != Error::OK;
}

const char *AnimationParser::Error::typeString() const {
    switch (type) {
        case Error::OK:
            return "OK";
        case Error::JSON_SYNTAX_ERROR:
            return "JSON_SYNTAX_ERROR";
        case Error::UNEXPECTED_END_OF_FILE:
            return "UNEXPECTED_END_OF_FILE";
        case Error::TYPE_MISMATCH:
            return "TYPE_MISMATCH";
        case Error::ARRAY_SIZE_MISMATCH:
            return "ARRAY_SIZE_MISMATCH";
        case Error::UNKNOWN_ENUM_VALUE:
            return "UNKNOWN_ENUM_VALUE";
        case Error::UNKNOWN_KEY:
            return "UNKNOWN_KEY";
        case Error::MISSING_KEY:
            return "MISSING_KEY";
        case Error::REPEATED_KEY:
            return "REPEATED_KEY";
        case Error::VALUE_OUT_OF_RANGE:
            return "VALUE_OUT_OF_RANGE";
        case Error::STRING_EXPECTED:
            return "STRING_EXPECTED";
        case Error::UTF16_ENCODING_ERROR:
            return "UTF16_ENCODING_ERROR";
    }
    return "";
}

AnimationParser::AnimationParser(const char *str) : cur(str) { }

void AnimationParser::skipWhitespace() {
    while (*cur == ' ' || *cur == '\t' || *cur == '\r' || *cur == '\n')
        ++cur;
}

AnimationParser::Error::Type AnimationParser::skipValue() {
    skipWhitespace();
    switch (*cur) {
        case '\0':
            return Error::UNEXPECTED_END_OF_FILE;
        case '"':
            while (*++cur != '"') {
                if (!*(cur += *cur == '\\'))
                    return Error::UNEXPECTED_END_OF_FILE;
            }
            ++cur;
            return Error::OK;
        case '[': case '{':
            ++cur;
            for (int openBrackets = 1; openBrackets;) {
                switch (*cur) {
                    case '\0':
                        return Error::UNEXPECTED_END_OF_FILE;
                    case '"':
                        if (Error::Type error = skipValue())
                            return error;
                        continue;
                    case '[': case '{':
                        ++openBrackets;
                        break;
                    case ']': case '}':
                        --openBrackets;
                        break;
                }
                ++cur;
            }
            return Error::OK;
        default:
            if (isAlphanumeric(*cur) || *cur == '-' || *cur == '.') {
                while (isAlphanumeric(*++cur) || *cur == '+' || *cur == '-' || *cur == '.');
                return Error::OK;
            }
    }
    return Error::JSON_SYNTAX_ERROR;
}

bool AnimationParser::matchSymbol(char s) {
    skipWhitespace();
    if (*cur == s) {
        ++cur;
        return true;
    }
    return false;
}

bool AnimationParser::readHexQuad(int &value) {
    return (
        cur[0] && cur[1] && cur[2] && cur[3] &&
        (value = decodeHexDigit(cur[3])) >= 0 &&
        (value += 0x0010*decodeHexDigit(cur[2])) >= 0 &&
        (value += 0x0100*decodeHexDigit(cur[1])) >= 0 &&
        (value += 0x1000*decodeHexDigit(cur[0])) >= 0 &&
        (cur += 4, true)
    );
}

AnimationParser::Error::Type AnimationParser::unescape(char *codepoints) {
    switch (++cur, *cur++) {
        case '\0':
            --cur;
            return Error::UNEXPECTED_END_OF_FILE;
        case 'B': case 'b': codepoints[0] = '\b'; break;
        case 'F': case 'f': codepoints[0] = '\f'; break;
        case 'N': case 'n': codepoints[0] = '\n'; break;
        case 'R': case 'r': codepoints[0] = '\r'; break;
        case 'T': case 't': codepoints[0] = '\t'; break;
        case 'U': case 'u': {
            unsigned long cp;
            int wc;
            if (!readHexQuad(wc))
                return Error::JSON_SYNTAX_ERROR;
            if ((wc&0xfc00) == 0xd800) {
                if (!(cur[0] == '\\' && (cur[1] == 'u' || cur[1] == 'U')))
                    return Error::UTF16_ENCODING_ERROR;
                cp = (unsigned long) ((wc&0x03ff)<<10);
                cur += 2;
                if (!readHexQuad(wc))
                    return Error::JSON_SYNTAX_ERROR;
                if ((wc&0xfc00) != 0xdc00)
                    return Error::UTF16_ENCODING_ERROR;
                cp = 0x010000+(cp|(unsigned long) (wc&0x03ff));
            } else
                cp = (unsigned long) wc;
            if (cp&0xffffff80) {
                int len;
                for (len = 1; cp>>(5*len+1) && len < 6; ++len);
                codepoints[0] = (char) (0xff<<(8-len)|cp>>6*(len-1));
                for (int i = 1; i < len; ++i)
                    *++codepoints = (char) (0x80|(cp>>6*(len-i-1)&0x3f));
            } else
                codepoints[0] = (char) cp;
            break;
        }
        default:
            codepoints[0] = cur[-1];
    }
    codepoints[1] = '\0';
    return Error::OK;
}

bool AnimationParser::isAlphanumeric(char c) {
    switch (c) {
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I':
        case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i':
        case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
        case 's': case 't': case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
            return true;
        default:
            return false;
    }
}

int AnimationParser::decodeHexDigit(char digit) {
    switch (digit) {
        case '0': return 0x00;
        case '1': return 0x01;
        case '2': return 0x02;
        case '3': return 0x03;
        case '4': return 0x04;
        case '5': return 0x05;
        case '6': return 0x06;
        case '7': return 0x07;
        case '8': return 0x08;
        case '9': return 0x09;
        case 'A': case 'a': return 0x0a;
        case 'B': case 'b': return 0x0b;
        case 'C': case 'c': return 0x0c;
        case 'D': case 'd': return 0x0d;
        case 'E': case 'e': return 0x0e;
        case 'F': case 'f': return 0x0f;
    }
    return -1;
}

AnimationParser::Error AnimationParser::parse(ode::DocumentAnimation &output, const char *jsonString) {
    AnimationParser parser(jsonString);
    Error::Type error = parser.parseOdeDocumentAnimation(output);
    return Error(error, static_cast<int>(parser.cur-jsonString));
}

AnimationParser::Error::Type AnimationParser::parseStdString(std::string &value) {
    if (!matchSymbol('"'))
        return Error::STRING_EXPECTED;
    value.clear();
    while (*cur != '"') {
        if (*cur == '\\') {
            char utfBuffer[8];
            if (Error error = unescape(utfBuffer))
                return error;
            value += utfBuffer;
            continue;
        }
        if (!*cur)
            return Error::UNEXPECTED_END_OF_FILE;
        value.push_back(*cur);
        ++cur;
    }
    ++cur;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseOdeLayerAnimationType(ode::LayerAnimation::Type &value) {
    if (Error::Type error = parseStdString(buffer))
        return error;
    switch (buffer.size()) {
        case 7:
            if (buffer == "OPACITY") {
                value = ode::LayerAnimation::OPACITY;
                return Error::OK; 
            }
            break;
        case 8:
            if (buffer == "ROTATION") {
                value = ode::LayerAnimation::ROTATION;
                return Error::OK; 
            }
            break;
        case 9:
            if (buffer == "TRANSFORM") {
                value = ode::LayerAnimation::TRANSFORM;
                return Error::OK; 
            }
            break;
        case 10:
            if (buffer == "FILL_COLOR") {
                value = ode::LayerAnimation::FILL_COLOR;
                return Error::OK; 
            }
            break;
    }
    return Error::UNKNOWN_ENUM_VALUE;
}

AnimationParser::Error::Type AnimationParser::parseDouble(double &value) {
    char *end;
    value = strtod(cur, &end);
    if (end == cur)
        return Error::TYPE_MISMATCH;
    cur = end;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseOctopusColor(octopus::Color &value) {
    if (!matchSymbol('{'))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    for (; !matchSymbol('}'); separatorCheck = matchSymbol(',')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseStdString(buffer))
            return error;
        if (!matchSymbol(':'))
            return Error::JSON_SYNTAX_ERROR;
        if (buffer.size() > 0) {
            switch (buffer[0]) {
                case 'a':
                    if (buffer == "a") {
                        if (Error error = parseDouble(value.a))
                            return error;
                        continue;
                    }
                    break;
                case 'b':
                    if (buffer == "b") {
                        if (Error error = parseDouble(value.b))
                            return error;
                        continue;
                    }
                    break;
                case 'g':
                    if (buffer == "g") {
                        if (Error error = parseDouble(value.g))
                            return error;
                        continue;
                    }
                    break;
                case 'r':
                    if (buffer == "r") {
                        if (Error error = parseDouble(value.r))
                            return error;
                        continue;
                    }
                    break;
            }
        }
        if (Error error = skipValue())
            return error;
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseNonstdOptionalOctopusColor(nonstd::optional<octopus::Color> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && (cur += 4, true))
        value.reset();
    else if (Error error = parseOctopusColor((value = octopus::Color()).value()))
        return error;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseStdVectorDouble(std::vector<double> &value) {
    if (!matchSymbol('['))
        return Error::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseDouble((value.resize(value.size()+1), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseNonstdOptionalStdVectorDouble(nonstd::optional<std::vector<double> > &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && (cur += 4, true))
        value.reset();
    else if (Error error = parseStdVectorDouble((value = std::vector<double>()).value()))
        return error;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseNonstdOptionalDouble(nonstd::optional<double> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && (cur += 4, true))
        value.reset();
    else if (Error error = parseDouble((value = double()).value()))
        return error;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseStdArrayDouble6(std::array<double, 6> &value) {
    if (!matchSymbol('['))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    int i = 0;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (i == 6)
            return Error::ARRAY_SIZE_MISMATCH;
        if (Error::Type error = parseDouble(value[i]))
            return error;
        ++i;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    if (i != 6)
        return Error::ARRAY_SIZE_MISMATCH;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseNonstdOptionalStdArrayDouble6(nonstd::optional<std::array<double, 6> > &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && (cur += 4, true))
        value.reset();
    else if (Error error = parseStdArrayDouble6((value = std::array<double, 6>()).value()))
        return error;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseOdeLayerAnimationKeyframe(ode::LayerAnimation::Keyframe &value) {
    if (!matchSymbol('{'))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    for (; !matchSymbol('}'); separatorCheck = matchSymbol(',')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseStdString(buffer))
            return error;
        if (!matchSymbol(':'))
            return Error::JSON_SYNTAX_ERROR;
        if (buffer.size() > 0) {
            switch (buffer[0]) {
                case 'c':
                    if (buffer == "color") {
                        if (Error error = parseNonstdOptionalOctopusColor(value.color))
                            return error;
                        continue;
                    }
                    break;
                case 'd':
                    if (buffer == "delay") {
                        if (Error error = parseDouble(value.delay))
                            return error;
                        continue;
                    }
                    break;
                case 'e':
                    if (buffer == "easing") {
                        if (Error error = parseNonstdOptionalStdVectorDouble(value.easing))
                            return error;
                        continue;
                    }
                    break;
                case 'o':
                    if (buffer == "opacity") {
                        if (Error error = parseNonstdOptionalDouble(value.opacity))
                            return error;
                        continue;
                    }
                    break;
                case 'r':
                    if (buffer == "rotation") {
                        if (Error error = parseNonstdOptionalDouble(value.rotation))
                            return error;
                        continue;
                    }
                    break;
                case 't':
                    if (buffer == "transform") {
                        if (Error error = parseNonstdOptionalStdArrayDouble6(value.transform))
                            return error;
                        continue;
                    }
                    break;
            }
        }
        if (Error error = skipValue())
            return error;
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseStdVectorOdeLayerAnimationKeyframe(std::vector<ode::LayerAnimation::Keyframe> &value) {
    if (!matchSymbol('['))
        return Error::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseOdeLayerAnimationKeyframe((value.resize(value.size()+1), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseStdArrayDouble2(std::array<double, 2> &value) {
    if (!matchSymbol('['))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    int i = 0;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (i == 2)
            return Error::ARRAY_SIZE_MISMATCH;
        if (Error::Type error = parseDouble(value[i]))
            return error;
        ++i;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    if (i != 2)
        return Error::ARRAY_SIZE_MISMATCH;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseNonstdOptionalStdArrayDouble2(nonstd::optional<std::array<double, 2> > &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && (cur += 4, true))
        value.reset();
    else if (Error error = parseStdArrayDouble2((value = std::array<double, 2>()).value()))
        return error;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseOdeLayerAnimation(ode::LayerAnimation &value) {
    if (!matchSymbol('{'))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    for (; !matchSymbol('}'); separatorCheck = matchSymbol(',')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseStdString(buffer))
            return error;
        if (!matchSymbol(':'))
            return Error::JSON_SYNTAX_ERROR;
        switch (buffer.size()) {
            case 4:
                if (buffer == "type") {
                    if (Error error = parseOdeLayerAnimationType(value.type))
                        return error;
                    continue;
                }
                break;
            case 5:
                if (buffer == "layer") {
                    if (Error error = parseStdString(value.layer))
                        return error;
                    continue;
                }
                break;
            case 9:
                if (buffer == "keyframes") {
                    if (Error error = parseStdVectorOdeLayerAnimationKeyframe(value.keyframes))
                        return error;
                    continue;
                }
                break;
            case 14:
                if (buffer == "rotationCenter") {
                    if (Error error = parseNonstdOptionalStdArrayDouble2(value.rotationCenter))
                        return error;
                    continue;
                }
                break;
        }
        if (Error error = skipValue())
            return error;
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseStdVectorOdeLayerAnimation(std::vector<ode::LayerAnimation> &value) {
    if (!matchSymbol('['))
        return Error::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseOdeLayerAnimation((value.resize(value.size()+1), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

AnimationParser::Error::Type AnimationParser::parseOdeDocumentAnimation(ode::DocumentAnimation &value) {
    if (!matchSymbol('{'))
        return Error::TYPE_MISMATCH;
    int separatorCheck = -1;
    for (; !matchSymbol('}'); separatorCheck = matchSymbol(',')) {
        if (!separatorCheck)
            return Error::JSON_SYNTAX_ERROR;
        if (Error::Type error = parseStdString(buffer))
            return error;
        if (!matchSymbol(':'))
            return Error::JSON_SYNTAX_ERROR;
        if (buffer == "animations") {
            if (Error error = parseStdVectorOdeLayerAnimation(value.animations))
                return error;
            continue;
        }
        if (Error error = skipValue())
            return error;
    }
    if (separatorCheck == 1)
        return Error::JSON_SYNTAX_ERROR;
    return Error::OK;
}

}
