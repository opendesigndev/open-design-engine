
// FILE GENERATED BY generate-api-bindings.py
#include <string>
#include "addon.h"
#include "napi-wrap.h"
#include "gen-api-base.h"
#include "gen-api-base.h"
Napi::Value bind_ode_destroyString(const Napi::CallbackInfo& info);
Napi::Value bind_ode_allocateMemoryBuffer(const Napi::CallbackInfo& info);
Napi::Value bind_ode_reallocateMemoryBuffer(const Napi::CallbackInfo& info);
Napi::Value bind_ode_destroyMemoryBuffer(const Napi::CallbackInfo& info);

Napi::Object init_gen_api_base(Napi::Env env, Napi::Object exports) {

    {
        auto Result = Napi::Object::New(env);
        Result.Set("OK", uint32_t(ODE_RESULT_OK));
        Result.Set("UNKNOWN_ERROR", uint32_t(ODE_RESULT_UNKNOWN_ERROR));
        Result.Set("NOT_IMPLEMENTED", uint32_t(ODE_RESULT_NOT_IMPLEMENTED));
        Result.Set("MEMORY_ALLOCATION_ERROR", uint32_t(ODE_RESULT_MEMORY_ALLOCATION_ERROR));
        Result.Set("FILE_READ_ERROR", uint32_t(ODE_RESULT_FILE_READ_ERROR));
        Result.Set("FILE_WRITE_ERROR", uint32_t(ODE_RESULT_FILE_WRITE_ERROR));
        Result.Set("OCTOPUS_PARSE_ERROR", uint32_t(ODE_RESULT_OCTOPUS_PARSE_ERROR));
        Result.Set("OCTOPUS_MANIFEST_PARSE_ERROR", uint32_t(ODE_RESULT_OCTOPUS_MANIFEST_PARSE_ERROR));
        Result.Set("ANIMATION_PARSE_ERROR", uint32_t(ODE_RESULT_ANIMATION_PARSE_ERROR));
        Result.Set("ITEM_NOT_FOUND", uint32_t(ODE_RESULT_ITEM_NOT_FOUND));
        Result.Set("LAYER_NOT_FOUND", uint32_t(ODE_RESULT_LAYER_NOT_FOUND));
        Result.Set("COMPONENT_NOT_FOUND", uint32_t(ODE_RESULT_COMPONENT_NOT_FOUND));
        Result.Set("DUPLICATE_COMPONENT_ID", uint32_t(ODE_RESULT_DUPLICATE_COMPONENT_ID));
        Result.Set("DUPLICATE_LAYER_ID", uint32_t(ODE_RESULT_DUPLICATE_LAYER_ID));
        Result.Set("OCTOPUS_UNAVAILABLE", uint32_t(ODE_RESULT_OCTOPUS_UNAVAILABLE));
        Result.Set("COMPONENT_IN_USE", uint32_t(ODE_RESULT_COMPONENT_IN_USE));
        Result.Set("ALREADY_INITIALIZED", uint32_t(ODE_RESULT_ALREADY_INITIALIZED));
        Result.Set("SHAPE_LAYER_ERROR", uint32_t(ODE_RESULT_SHAPE_LAYER_ERROR));
        Result.Set("TEXT_LAYER_ERROR", uint32_t(ODE_RESULT_TEXT_LAYER_ERROR));
        Result.Set("WRONG_LAYER_TYPE", uint32_t(ODE_RESULT_WRONG_LAYER_TYPE));
        Result.Set("INVALID_DESIGN", uint32_t(ODE_RESULT_INVALID_DESIGN));
        Result.Set("INVALID_COMPONENT", uint32_t(ODE_RESULT_INVALID_COMPONENT));
        Result.Set("INVALID_PIXEL_FORMAT", uint32_t(ODE_RESULT_INVALID_PIXEL_FORMAT));
        Result.Set("INVALID_BITMAP_DIMENSIONS", uint32_t(ODE_RESULT_INVALID_BITMAP_DIMENSIONS));
        Result.Set("INVALID_RENDERER_CONTEXT", uint32_t(ODE_RESULT_INVALID_RENDERER_CONTEXT));
        Result.Set("INVALID_IMAGE_BASE", uint32_t(ODE_RESULT_INVALID_IMAGE_BASE));
        Result.Set("FONT_ERROR", uint32_t(ODE_RESULT_FONT_ERROR));
        Result.Set("GRAPHICS_CONTEXT_ERROR", uint32_t(ODE_RESULT_GRAPHICS_CONTEXT_ERROR));
        exports.Set("Result", Result);
    }

    // TODO: typedef Scalar

    // TODO: typedef VarDataPtr

    // TODO: typedef ConstDataPtr

    // TODO: typedef ConstCharPtr

    // TODO: tuple Vector2

    // TODO: tuple Rectangle





    exports.Set("destroyString", Napi::Function::New<bind_ode_destroyString>(env, "destroyString"));
    exports.Set("allocateMemoryBuffer", Napi::Function::New<bind_ode_allocateMemoryBuffer>(env, "allocateMemoryBuffer"));
    exports.Set("reallocateMemoryBuffer", Napi::Function::New<bind_ode_reallocateMemoryBuffer>(env, "reallocateMemoryBuffer"));
    exports.Set("destroyMemoryBuffer", Napi::Function::New<bind_ode_destroyMemoryBuffer>(env, "destroyMemoryBuffer"));    return exports;
}

std::string Result_to_string(ODE_Result value) {
    switch(value) {
        case ODE_RESULT_OK: return "OK";
        case ODE_RESULT_UNKNOWN_ERROR: return "UNKNOWN_ERROR";
        case ODE_RESULT_NOT_IMPLEMENTED: return "NOT_IMPLEMENTED";
        case ODE_RESULT_MEMORY_ALLOCATION_ERROR: return "MEMORY_ALLOCATION_ERROR";
        case ODE_RESULT_FILE_READ_ERROR: return "FILE_READ_ERROR";
        case ODE_RESULT_FILE_WRITE_ERROR: return "FILE_WRITE_ERROR";
        case ODE_RESULT_OCTOPUS_PARSE_ERROR: return "OCTOPUS_PARSE_ERROR";
        case ODE_RESULT_OCTOPUS_MANIFEST_PARSE_ERROR: return "OCTOPUS_MANIFEST_PARSE_ERROR";
        case ODE_RESULT_ANIMATION_PARSE_ERROR: return "ANIMATION_PARSE_ERROR";
        case ODE_RESULT_ITEM_NOT_FOUND: return "ITEM_NOT_FOUND";
        case ODE_RESULT_LAYER_NOT_FOUND: return "LAYER_NOT_FOUND";
        case ODE_RESULT_COMPONENT_NOT_FOUND: return "COMPONENT_NOT_FOUND";
        case ODE_RESULT_DUPLICATE_COMPONENT_ID: return "DUPLICATE_COMPONENT_ID";
        case ODE_RESULT_DUPLICATE_LAYER_ID: return "DUPLICATE_LAYER_ID";
        case ODE_RESULT_OCTOPUS_UNAVAILABLE: return "OCTOPUS_UNAVAILABLE";
        case ODE_RESULT_COMPONENT_IN_USE: return "COMPONENT_IN_USE";
        case ODE_RESULT_ALREADY_INITIALIZED: return "ALREADY_INITIALIZED";
        case ODE_RESULT_SHAPE_LAYER_ERROR: return "SHAPE_LAYER_ERROR";
        case ODE_RESULT_TEXT_LAYER_ERROR: return "TEXT_LAYER_ERROR";
        case ODE_RESULT_WRONG_LAYER_TYPE: return "WRONG_LAYER_TYPE";
        case ODE_RESULT_INVALID_DESIGN: return "INVALID_DESIGN";
        case ODE_RESULT_INVALID_COMPONENT: return "INVALID_COMPONENT";
        case ODE_RESULT_INVALID_PIXEL_FORMAT: return "INVALID_PIXEL_FORMAT";
        case ODE_RESULT_INVALID_BITMAP_DIMENSIONS: return "INVALID_BITMAP_DIMENSIONS";
        case ODE_RESULT_INVALID_RENDERER_CONTEXT: return "INVALID_RENDERER_CONTEXT";
        case ODE_RESULT_INVALID_IMAGE_BASE: return "INVALID_IMAGE_BASE";
        case ODE_RESULT_FONT_ERROR: return "FONT_ERROR";
        case ODE_RESULT_GRAPHICS_CONTEXT_ERROR: return "GRAPHICS_CONTEXT_ERROR";
        default: return "UNKNOWN_Result_"+std::to_string(uint32_t(value));
    }
}
template<>
Napi::Value Autobind<ODE_Result>::serialize(Napi::Env env, const ODE_Result& source){
    return Napi::String::New(env, Result_to_string(source));
}

template<>
bool Autobind<ODE_StringRef>::read_into(const Napi::Value& value, ODE_StringRef& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    uintptr_t ptr_data;
    if(Autobind<uintptr_t>::read_into(obj.Get("data"), ptr_data)) {
        parsed.data = reinterpret_cast<ODE_ConstCharPtr>(ptr_data);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field data").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("length"), parsed.length)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field length").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
template<>
Napi::Value Autobind<ODE_StringRef>::serialize(Napi::Env env, const ODE_StringRef& source){
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value data = Autobind<uintptr_t>::serialize(env, (uintptr_t)source.data);
    if(data.IsEmpty()) return Napi::Value();
    obj.Set("data", data);
    Napi::Value length = Autobind<int>::serialize(env, source.length);
    if(length.IsEmpty()) return Napi::Value();
    obj.Set("length", length);
    return obj;
}

template<>
bool Autobind<ODE_String>::read_into(const Napi::Value& value, ODE_String& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    uintptr_t ptr_data;
    if(Autobind<uintptr_t>::read_into(obj.Get("data"), ptr_data)) {
        parsed.data = reinterpret_cast<char *>(ptr_data);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field data").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("length"), parsed.length)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field length").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
template<>
Napi::Value Autobind<ODE_String>::serialize(Napi::Env env, const ODE_String& source){
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value data = Autobind<uintptr_t>::serialize(env, (uintptr_t)source.data);
    if(data.IsEmpty()) return Napi::Value();
    obj.Set("data", data);
    Napi::Value length = Autobind<int>::serialize(env, source.length);
    if(length.IsEmpty()) return Napi::Value();
    obj.Set("length", length);
    return obj;
}

template<>
bool Autobind<ODE_MemoryBuffer>::read_into(const Napi::Value& value, ODE_MemoryBuffer& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    uintptr_t ptr_data;
    if(Autobind<uintptr_t>::read_into(obj.Get("data"), ptr_data)) {
        parsed.data = reinterpret_cast<ODE_VarDataPtr>(ptr_data);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field data").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<size_t>::read_into(obj.Get("length"), parsed.length)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field length").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
template<>
Napi::Value Autobind<ODE_MemoryBuffer>::serialize(Napi::Env env, const ODE_MemoryBuffer& source){
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value data = Autobind<uintptr_t>::serialize(env, (uintptr_t)source.data);
    if(data.IsEmpty()) return Napi::Value();
    obj.Set("data", data);
    Napi::Value length = Autobind<size_t>::serialize(env, source.length);
    if(length.IsEmpty()) return Napi::Value();
    obj.Set("length", length);
    return obj;
}

template<>
bool Autobind<ODE_StringList>::read_into(const Napi::Value& value, ODE_StringList& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    uintptr_t ptr_entries;
    if(Autobind<uintptr_t>::read_into(obj.Get("entries"), ptr_entries)) {
        parsed.entries = reinterpret_cast<ODE_StringRef *>(ptr_entries);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field entries").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("n"), parsed.n)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field n").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
template<>
Napi::Value Autobind<ODE_StringList>::serialize(Napi::Env env, const ODE_StringList& source){
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value entries = Autobind<uintptr_t>::serialize(env, (uintptr_t)source.entries);
    if(entries.IsEmpty()) return Napi::Value();
    obj.Set("entries", entries);
    Napi::Value n = Autobind<int>::serialize(env, source.n);
    if(n.IsEmpty()) return Napi::Value();
    obj.Set("n", n);
    return obj;
}

Napi::Value bind_ode_destroyString(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    ODE_String string;
    if(!Autobind<ODE_String>::read_into(info[0], string)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument string ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto result = ode_destroyString(string);
    return Napi::String::New(env, Result_to_string(result));
}

Napi::Value bind_ode_allocateMemoryBuffer(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    ODE_MemoryBuffer buffer;
    if(!Autobind<ODE_MemoryBuffer>::read_into(info[0], buffer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument buffer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    size_t length;
    if(!Autobind<size_t>::read_into(info[1], length)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument length ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto result = ode_allocateMemoryBuffer(&buffer, length);
    Autobind<ODE_MemoryBuffer>::write_from(info[0], buffer);
    return Napi::String::New(env, Result_to_string(result));
}

Napi::Value bind_ode_reallocateMemoryBuffer(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    ODE_MemoryBuffer buffer;
    if(!Autobind<ODE_MemoryBuffer>::read_into(info[0], buffer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument buffer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    size_t length;
    if(!Autobind<size_t>::read_into(info[1], length)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument length ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto result = ode_reallocateMemoryBuffer(&buffer, length);
    Autobind<ODE_MemoryBuffer>::write_from(info[0], buffer);
    return Napi::String::New(env, Result_to_string(result));
}

Napi::Value bind_ode_destroyMemoryBuffer(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    ODE_MemoryBuffer buffer;
    if(!Autobind<ODE_MemoryBuffer>::read_into(info[0], buffer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument buffer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto result = ode_destroyMemoryBuffer(&buffer);
    Autobind<ODE_MemoryBuffer>::write_from(info[0], buffer);
    return Napi::String::New(env, Result_to_string(result));
}

