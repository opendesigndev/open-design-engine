
// FILE GENERATED BY generate-api-bindings.py
#include <string>
#include "addon.h"
#include "napi-wrap.h"
#include "gen.h"

void node_napi_destroyBitmap(const Napi::CallbackInfo& info);
void node_napi_createRendererContext(const Napi::CallbackInfo& info);
void node_napi_destroyRendererContext(const Napi::CallbackInfo& info);
void node_napi_createDesignImageBase(const Napi::CallbackInfo& info);
void node_napi_destroyDesignImageBase(const Napi::CallbackInfo& info);
void node_napi_design_loadImagePixels(const Napi::CallbackInfo& info);
void node_napi_pr1_drawComponent(const Napi::CallbackInfo& info);
void node_napi_pr1_createAnimationRenderer(const Napi::CallbackInfo& info);
void node_napi_pr1_destroyAnimationRenderer(const Napi::CallbackInfo& info);
void node_napi_pr1_animation_drawFrame(const Napi::CallbackInfo& info);

Napi::Object init_gen_renderer_api(Napi::Env env, Napi::Object exports) {

    exports.Set("PIXEL_FORMAT_RGBA", uint32_t(ODE_PIXEL_FORMAT_RGBA));

    exports.Set("PIXEL_FORMAT_PREMULTIPLIED_RGBA", uint32_t(ODE_PIXEL_FORMAT_PREMULTIPLIED_RGBA));




    Handle<ODE_RendererContextHandle>::Export(exports);
    Handle<ODE_DesignImageBaseHandle>::Export(exports);
    Handle<ODE_PR1_AnimationRendererHandle>::Export(exports);
    exports.Set("destroyBitmap", Napi::Function::New<node_napi_destroyBitmap>(env, "destroyBitmap"));
    exports.Set("createRendererContext", Napi::Function::New<node_napi_createRendererContext>(env, "createRendererContext"));
    exports.Set("destroyRendererContext", Napi::Function::New<node_napi_destroyRendererContext>(env, "destroyRendererContext"));
    exports.Set("createDesignImageBase", Napi::Function::New<node_napi_createDesignImageBase>(env, "createDesignImageBase"));
    exports.Set("destroyDesignImageBase", Napi::Function::New<node_napi_destroyDesignImageBase>(env, "destroyDesignImageBase"));
    exports.Set("design_loadImagePixels", Napi::Function::New<node_napi_design_loadImagePixels>(env, "design_loadImagePixels"));
    exports.Set("pr1_drawComponent", Napi::Function::New<node_napi_pr1_drawComponent>(env, "pr1_drawComponent"));
    exports.Set("pr1_createAnimationRenderer", Napi::Function::New<node_napi_pr1_createAnimationRenderer>(env, "pr1_createAnimationRenderer"));
    exports.Set("pr1_destroyAnimationRenderer", Napi::Function::New<node_napi_pr1_destroyAnimationRenderer>(env, "pr1_destroyAnimationRenderer"));
    exports.Set("pr1_animation_drawFrame", Napi::Function::New<node_napi_pr1_animation_drawFrame>(env, "pr1_animation_drawFrame"));    return exports;
}

template<>
bool Autobind<ODE_Bitmap>::read_into(const Napi::Value& value, ODE_Bitmap& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<int>::read_into(obj.Get("format"), parsed.format)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field format").ThrowAsJavaScriptException();
        return false;
    }
    uintptr_t ptr_pixels;
    if(Autobind<uintptr_t>::read_into(obj.Get("pixels"), ptr_pixels)) {
        parsed.pixels = reinterpret_cast<ODE_VarDataPtr>(ptr_pixels);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field pixels").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("width"), parsed.width)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field width").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("height"), parsed.height)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field height").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_Bitmap& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value format = ode_napi_serialize(env, source.format);
    if(format.IsEmpty()) return Napi::Value();
    obj.Set("format", format);
    Napi::Value pixels = ode_napi_serialize(env, (uintptr_t)source.pixels);
    if(pixels.IsEmpty()) return Napi::Value();
    obj.Set("pixels", pixels);
    Napi::Value width = ode_napi_serialize(env, source.width);
    if(width.IsEmpty()) return Napi::Value();
    obj.Set("width", width);
    Napi::Value height = ode_napi_serialize(env, source.height);
    if(height.IsEmpty()) return Napi::Value();
    obj.Set("height", height);
    return obj;
}

template<>
bool Autobind<ODE_BitmapRef>::read_into(const Napi::Value& value, ODE_BitmapRef& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<int>::read_into(obj.Get("format"), parsed.format)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field format").ThrowAsJavaScriptException();
        return false;
    }
    uintptr_t ptr_pixels;
    if(Autobind<uintptr_t>::read_into(obj.Get("pixels"), ptr_pixels)) {
        parsed.pixels = reinterpret_cast<ODE_ConstDataPtr>(ptr_pixels);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field pixels").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("width"), parsed.width)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field width").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("height"), parsed.height)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field height").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_BitmapRef& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value format = ode_napi_serialize(env, source.format);
    if(format.IsEmpty()) return Napi::Value();
    obj.Set("format", format);
    Napi::Value pixels = ode_napi_serialize(env, (uintptr_t)source.pixels);
    if(pixels.IsEmpty()) return Napi::Value();
    obj.Set("pixels", pixels);
    Napi::Value width = ode_napi_serialize(env, source.width);
    if(width.IsEmpty()) return Napi::Value();
    obj.Set("width", width);
    Napi::Value height = ode_napi_serialize(env, source.height);
    if(height.IsEmpty()) return Napi::Value();
    obj.Set("height", height);
    return obj;
}

template<>
bool Autobind<ODE_PR1_FrameView>::read_into(const Napi::Value& value, ODE_PR1_FrameView& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<int>::read_into(obj.Get("width"), parsed.width)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field width").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("height"), parsed.height)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field height").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Vector2>::read_into(obj.Get("offset"), parsed.offset)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field offset").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Scalar>::read_into(obj.Get("scale"), parsed.scale)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field scale").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_PR1_FrameView& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value width = ode_napi_serialize(env, source.width);
    if(width.IsEmpty()) return Napi::Value();
    obj.Set("width", width);
    Napi::Value height = ode_napi_serialize(env, source.height);
    if(height.IsEmpty()) return Napi::Value();
    obj.Set("height", height);
    Napi::Value offset = ode_napi_serialize(env, source.offset);
    if(offset.IsEmpty()) return Napi::Value();
    obj.Set("offset", offset);
    Napi::Value scale = ode_napi_serialize(env, source.scale);
    if(scale.IsEmpty()) return Napi::Value();
    obj.Set("scale", scale);
    return obj;
}

template<>
const char* Handle<ODE_RendererContextHandle>::name = "RendererContextHandle";
template<>
bool Autobind<ODE_RendererContextHandle>::read_into(const Napi::Value& value, ODE_RendererContextHandle& target) {
    auto optional = Handle<ODE_RendererContextHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_RendererContextHandle& source) {
    return Handle<ODE_RendererContextHandle>::serialize(env, source);
}

template<>
const char* Handle<ODE_DesignImageBaseHandle>::name = "DesignImageBaseHandle";
template<>
bool Autobind<ODE_DesignImageBaseHandle>::read_into(const Napi::Value& value, ODE_DesignImageBaseHandle& target) {
    auto optional = Handle<ODE_DesignImageBaseHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_DesignImageBaseHandle& source) {
    return Handle<ODE_DesignImageBaseHandle>::serialize(env, source);
}

template<>
const char* Handle<ODE_PR1_AnimationRendererHandle>::name = "PR1_AnimationRendererHandle";
template<>
bool Autobind<ODE_PR1_AnimationRendererHandle>::read_into(const Napi::Value& value, ODE_PR1_AnimationRendererHandle& target) {
    auto optional = Handle<ODE_PR1_AnimationRendererHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_PR1_AnimationRendererHandle& source) {
    return Handle<ODE_PR1_AnimationRendererHandle>::serialize(env, source);
}

void node_napi_destroyBitmap(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_Bitmap bitmap;
    if(!Autobind<ODE_Bitmap>::read_into(info[0], bitmap)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument bitmap ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyBitmap(bitmap);
    check_result(env, result);
}

void node_napi_createRendererContext(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_EngineHandle engine;
    if(!Autobind<ODE_EngineHandle>::read_into(info[0], engine)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument engine ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_RendererContextHandle rendererContext;
    if(!Autobind<ODE_RendererContextHandle>::read_into(info[1], rendererContext)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument rendererContext ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef target;
    if(!Autobind<ODE_StringRef>::read_into(info[2], target)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument target ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_createRendererContext(engine, &rendererContext, target);
    Autobind<ODE_RendererContextHandle>::write_from(info[1], rendererContext);
    check_result(env, result);
}

void node_napi_destroyRendererContext(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_RendererContextHandle rendererContext;
    if(!Autobind<ODE_RendererContextHandle>::read_into(info[0], rendererContext)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument rendererContext ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyRendererContext(rendererContext);
    check_result(env, result);
}

void node_napi_createDesignImageBase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_RendererContextHandle rendererContext;
    if(!Autobind<ODE_RendererContextHandle>::read_into(info[0], rendererContext)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument rendererContext ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[1], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_DesignImageBaseHandle designImageBase;
    if(!Autobind<ODE_DesignImageBaseHandle>::read_into(info[2], designImageBase)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument designImageBase ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_createDesignImageBase(rendererContext, design, &designImageBase);
    Autobind<ODE_DesignImageBaseHandle>::write_from(info[2], designImageBase);
    check_result(env, result);
}

void node_napi_destroyDesignImageBase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignImageBaseHandle designImageBase;
    if(!Autobind<ODE_DesignImageBaseHandle>::read_into(info[0], designImageBase)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument designImageBase ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyDesignImageBase(designImageBase);
    check_result(env, result);
}

void node_napi_design_loadImagePixels(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignImageBaseHandle designImageBase;
    if(!Autobind<ODE_DesignImageBaseHandle>::read_into(info[0], designImageBase)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument designImageBase ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef key;
    if(!Autobind<ODE_StringRef>::read_into(info[1], key)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument key ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_BitmapRef bitmap;
    if(!Autobind<ODE_BitmapRef>::read_into(info[2], bitmap)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument bitmap ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_design_loadImagePixels(designImageBase, key, bitmap);
    check_result(env, result);
}

void node_napi_pr1_drawComponent(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_RendererContextHandle rendererContext;
    if(!Autobind<ODE_RendererContextHandle>::read_into(info[0], rendererContext)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument rendererContext ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[1], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_DesignImageBaseHandle designImageBase;
    if(!Autobind<ODE_DesignImageBaseHandle>::read_into(info[2], designImageBase)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument designImageBase ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_Bitmap outputBitmap;
    if(!Autobind<ODE_Bitmap>::read_into(info[3], outputBitmap)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument outputBitmap ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_PR1_FrameView frameView;
    if(!Autobind<ODE_PR1_FrameView>::read_into(info[4], frameView)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument frameView ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_pr1_drawComponent(rendererContext, component, designImageBase, &outputBitmap, &frameView);
    Autobind<ODE_Bitmap>::write_from(info[3], outputBitmap);
    check_result(env, result);
}

void node_napi_pr1_createAnimationRenderer(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_RendererContextHandle rendererContext;
    if(!Autobind<ODE_RendererContextHandle>::read_into(info[0], rendererContext)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument rendererContext ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[1], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_PR1_AnimationRendererHandle animationRenderer;
    if(!Autobind<ODE_PR1_AnimationRendererHandle>::read_into(info[2], animationRenderer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument animationRenderer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_DesignImageBaseHandle imageBase;
    if(!Autobind<ODE_DesignImageBaseHandle>::read_into(info[3], imageBase)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument imageBase ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_pr1_createAnimationRenderer(rendererContext, component, &animationRenderer, imageBase);
    Autobind<ODE_PR1_AnimationRendererHandle>::write_from(info[2], animationRenderer);
    check_result(env, result);
}

void node_napi_pr1_destroyAnimationRenderer(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_PR1_AnimationRendererHandle animationRenderer;
    if(!Autobind<ODE_PR1_AnimationRendererHandle>::read_into(info[0], animationRenderer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument animationRenderer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_pr1_destroyAnimationRenderer(animationRenderer);
    check_result(env, result);
}

void node_napi_pr1_animation_drawFrame(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_PR1_AnimationRendererHandle renderer;
    if(!Autobind<ODE_PR1_AnimationRendererHandle>::read_into(info[0], renderer)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument renderer ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_PR1_FrameView frameView;
    if(!Autobind<ODE_PR1_FrameView>::read_into(info[1], frameView)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument frameView ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_Scalar time;
    if(!Autobind<ODE_Scalar>::read_into(info[2], time)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument time ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_pr1_animation_drawFrame(renderer, &frameView, time);
    check_result(env, result);
}

