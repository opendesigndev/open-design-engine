
// FILE GENERATED BY generate-api-bindings.py
#include <string>
#include "addon.h"
#include "napi-wrap.h"
#include "gen.h"

Napi::Value node_napi_LayerList_getEntry(const Napi::CallbackInfo& info);
void node_napi_destroyLayerList(const Napi::CallbackInfo& info);
void node_napi_destroyMissingFontList(const Napi::CallbackInfo& info);
Napi::Value node_napi_initializeEngineAttributes(const Napi::CallbackInfo& info);
Napi::Value node_napi_createEngine(const Napi::CallbackInfo& info);
void node_napi_destroyEngine(const Napi::CallbackInfo& info);
Napi::Value node_napi_createDesign(const Napi::CallbackInfo& info);
void node_napi_loadDesignFromManifestString(const Napi::CallbackInfo& info);
void node_napi_destroyDesign(const Napi::CallbackInfo& info);
void node_napi_design_loadManifestString(const Napi::CallbackInfo& info);
void node_napi_design_addComponentFromOctopusString(const Napi::CallbackInfo& info);
void node_napi_design_removeComponent(const Napi::CallbackInfo& info);
Napi::Value node_napi_design_listMissingFonts(const Napi::CallbackInfo& info);
void node_napi_design_loadFontBytes(const Napi::CallbackInfo& info);
void node_napi_design_getComponent(const Napi::CallbackInfo& info);
void node_napi_component_addLayer(const Napi::CallbackInfo& info);
void node_napi_component_modifyLayer(const Napi::CallbackInfo& info);
void node_napi_pr1_component_loadAnimation(const Napi::CallbackInfo& info);
void node_napi_pr1_component_getAnimationValueAtTime(const Napi::CallbackInfo& info);
Napi::Value node_napi_component_listLayers(const Napi::CallbackInfo& info);
void node_napi_component_identifyLayer(const Napi::CallbackInfo& info);
void node_napi_component_getLayerMetrics(const Napi::CallbackInfo& info);
Napi::Value node_napi_component_listMissingFonts(const Napi::CallbackInfo& info);
void node_napi_component_getOctopus(const Napi::CallbackInfo& info);

Napi::Object init_gen_logic_api(Napi::Env env, Napi::Object exports) {

    exports.Set("LAYER_FLAG_VISIBLE", uint32_t(ODE_LAYER_FLAG_VISIBLE));

    exports.Set("LAYER_FLAG_MASK", uint32_t(ODE_LAYER_FLAG_MASK));

    {
        auto LayerType = Napi::Object::New(env);
        LayerType.Set("UNSPECIFIED", uint32_t(ODE_LAYER_TYPE_UNSPECIFIED));
        LayerType.Set("SHAPE", uint32_t(ODE_LAYER_TYPE_SHAPE));
        LayerType.Set("TEXT", uint32_t(ODE_LAYER_TYPE_TEXT));
        LayerType.Set("GROUP", uint32_t(ODE_LAYER_TYPE_GROUP));
        LayerType.Set("MASK_GROUP", uint32_t(ODE_LAYER_TYPE_MASK_GROUP));
        LayerType.Set("COMPONENT_REFERENCE", uint32_t(ODE_LAYER_TYPE_COMPONENT_REFERENCE));
        LayerType.Set("COMPONENT_INSTANCE", uint32_t(ODE_LAYER_TYPE_COMPONENT_INSTANCE));
        exports.Set("LayerType", LayerType);
    }

    // TODO: array_instance Scalar_array_6





    exports.Set("LayerList_getEntry", Napi::Function::New<node_napi_LayerList_getEntry>(env, "LayerList_getEntry"));


    {
        auto ParseError_Type = Napi::Object::New(env);
        ParseError_Type.Set("OK", uint32_t(ODE_ParseError::OK));
        ParseError_Type.Set("JSON_SYNTAX_ERROR", uint32_t(ODE_ParseError::JSON_SYNTAX_ERROR));
        ParseError_Type.Set("UNEXPECTED_END_OF_FILE", uint32_t(ODE_ParseError::UNEXPECTED_END_OF_FILE));
        ParseError_Type.Set("TYPE_MISMATCH", uint32_t(ODE_ParseError::TYPE_MISMATCH));
        ParseError_Type.Set("ARRAY_SIZE_MISMATCH", uint32_t(ODE_ParseError::ARRAY_SIZE_MISMATCH));
        ParseError_Type.Set("UNKNOWN_KEY", uint32_t(ODE_ParseError::UNKNOWN_KEY));
        ParseError_Type.Set("UNKNOWN_ENUM_VALUE", uint32_t(ODE_ParseError::UNKNOWN_ENUM_VALUE));
        ParseError_Type.Set("VALUE_OUT_OF_RANGE", uint32_t(ODE_ParseError::VALUE_OUT_OF_RANGE));
        ParseError_Type.Set("STRING_EXPECTED", uint32_t(ODE_ParseError::STRING_EXPECTED));
        ParseError_Type.Set("UTF16_ENCODING_ERROR", uint32_t(ODE_ParseError::UTF16_ENCODING_ERROR));
        exports.Set("ParseError_Type", ParseError_Type);
    }


    Handle<ODE_EngineHandle>::Export(exports);
    Handle<ODE_DesignHandle>::Export(exports);
    Handle<ODE_ComponentHandle>::Export(exports);
    exports.Set("destroyLayerList", Napi::Function::New<node_napi_destroyLayerList>(env, "destroyLayerList"));
    exports.Set("destroyMissingFontList", Napi::Function::New<node_napi_destroyMissingFontList>(env, "destroyMissingFontList"));
    exports.Set("initializeEngineAttributes", Napi::Function::New<node_napi_initializeEngineAttributes>(env, "initializeEngineAttributes"));
    exports.Set("createEngine", Napi::Function::New<node_napi_createEngine>(env, "createEngine"));
    exports.Set("destroyEngine", Napi::Function::New<node_napi_destroyEngine>(env, "destroyEngine"));
    exports.Set("createDesign", Napi::Function::New<node_napi_createDesign>(env, "createDesign"));
    exports.Set("loadDesignFromManifestString", Napi::Function::New<node_napi_loadDesignFromManifestString>(env, "loadDesignFromManifestString"));
    exports.Set("destroyDesign", Napi::Function::New<node_napi_destroyDesign>(env, "destroyDesign"));
    exports.Set("design_loadManifestString", Napi::Function::New<node_napi_design_loadManifestString>(env, "design_loadManifestString"));
    exports.Set("design_addComponentFromOctopusString", Napi::Function::New<node_napi_design_addComponentFromOctopusString>(env, "design_addComponentFromOctopusString"));
    exports.Set("design_removeComponent", Napi::Function::New<node_napi_design_removeComponent>(env, "design_removeComponent"));
    exports.Set("design_listMissingFonts", Napi::Function::New<node_napi_design_listMissingFonts>(env, "design_listMissingFonts"));
    exports.Set("design_loadFontBytes", Napi::Function::New<node_napi_design_loadFontBytes>(env, "design_loadFontBytes"));
    exports.Set("design_getComponent", Napi::Function::New<node_napi_design_getComponent>(env, "design_getComponent"));
    exports.Set("component_addLayer", Napi::Function::New<node_napi_component_addLayer>(env, "component_addLayer"));
    exports.Set("component_modifyLayer", Napi::Function::New<node_napi_component_modifyLayer>(env, "component_modifyLayer"));
    exports.Set("pr1_component_loadAnimation", Napi::Function::New<node_napi_pr1_component_loadAnimation>(env, "pr1_component_loadAnimation"));
    exports.Set("pr1_component_getAnimationValueAtTime", Napi::Function::New<node_napi_pr1_component_getAnimationValueAtTime>(env, "pr1_component_getAnimationValueAtTime"));
    exports.Set("component_listLayers", Napi::Function::New<node_napi_component_listLayers>(env, "component_listLayers"));
    exports.Set("component_identifyLayer", Napi::Function::New<node_napi_component_identifyLayer>(env, "component_identifyLayer"));
    exports.Set("component_getLayerMetrics", Napi::Function::New<node_napi_component_getLayerMetrics>(env, "component_getLayerMetrics"));
    exports.Set("component_listMissingFonts", Napi::Function::New<node_napi_component_listMissingFonts>(env, "component_listMissingFonts"));
    exports.Set("component_getOctopus", Napi::Function::New<node_napi_component_getOctopus>(env, "component_getOctopus"));    return exports;
}

std::string ode_napi_enum_to_string(ODE_LayerType value) {
    switch(value) {
        case ODE_LAYER_TYPE_UNSPECIFIED: return "UNSPECIFIED";
        case ODE_LAYER_TYPE_SHAPE: return "SHAPE";
        case ODE_LAYER_TYPE_TEXT: return "TEXT";
        case ODE_LAYER_TYPE_GROUP: return "GROUP";
        case ODE_LAYER_TYPE_MASK_GROUP: return "MASK_GROUP";
        case ODE_LAYER_TYPE_COMPONENT_REFERENCE: return "COMPONENT_REFERENCE";
        case ODE_LAYER_TYPE_COMPONENT_INSTANCE: return "COMPONENT_INSTANCE";
        default: return "UNKNOWN_LayerType_"+std::to_string(uint32_t(value));
    }
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_LayerType& source) {
    return Napi::String::New(env, ode_napi_enum_to_string(source));
}

template<>
bool Autobind<ODE_Transformation>::read_into(const Napi::Value& value, ODE_Transformation& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<ODE_Scalar_array_6>::read_into(obj.Get("matrix"), parsed.matrix)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field matrix").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_Transformation& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value matrix = ode_napi_serialize(env, source.matrix);
    if(matrix.IsEmpty()) return Napi::Value();
    obj.Set("matrix", matrix);
    return obj;
}

template<>
bool Autobind<ODE_EngineAttributes>::read_into(const Napi::Value& value, ODE_EngineAttributes& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<int>::read_into(obj.Get("padding"), parsed.padding)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field padding").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_EngineAttributes& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value padding = ode_napi_serialize(env, source.padding);
    if(padding.IsEmpty()) return Napi::Value();
    obj.Set("padding", padding);
    return obj;
}

template<>
bool Autobind<ODE_ComponentMetadata>::read_into(const Napi::Value& value, ODE_ComponentMetadata& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<ODE_StringRef>::read_into(obj.Get("id"), parsed.id)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field id").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_StringRef>::read_into(obj.Get("page"), parsed.page)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field page").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Vector2>::read_into(obj.Get("position"), parsed.position)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field position").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_ComponentMetadata& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value id = ode_napi_serialize(env, source.id);
    if(id.IsEmpty()) return Napi::Value();
    obj.Set("id", id);
    Napi::Value page = ode_napi_serialize(env, source.page);
    if(page.IsEmpty()) return Napi::Value();
    obj.Set("page", page);
    Napi::Value position = ode_napi_serialize(env, source.position);
    if(position.IsEmpty()) return Napi::Value();
    obj.Set("position", position);
    return obj;
}

template<>
bool Autobind<ODE_LayerList::Entry>::read_into(const Napi::Value& value, ODE_LayerList::Entry& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<ODE_StringRef>::read_into(obj.Get("parentId"), parsed.parentId)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field parentId").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_StringRef>::read_into(obj.Get("id"), parsed.id)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field id").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_LayerType>::read_into(obj.Get("type"), parsed.type)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field type").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("flags"), parsed.flags)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field flags").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_StringRef>::read_into(obj.Get("name"), parsed.name)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field name").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_LayerList::Entry& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value parentId = ode_napi_serialize(env, source.parentId);
    if(parentId.IsEmpty()) return Napi::Value();
    obj.Set("parentId", parentId);
    Napi::Value id = ode_napi_serialize(env, source.id);
    if(id.IsEmpty()) return Napi::Value();
    obj.Set("id", id);
    Napi::Value type = ode_napi_serialize(env, source.type);
    if(type.IsEmpty()) return Napi::Value();
    obj.Set("type", type);
    Napi::Value flags = ode_napi_serialize(env, source.flags);
    if(flags.IsEmpty()) return Napi::Value();
    obj.Set("flags", flags);
    Napi::Value name = ode_napi_serialize(env, source.name);
    if(name.IsEmpty()) return Napi::Value();
    obj.Set("name", name);
    return obj;
}

Napi::Value node_napi_LayerList_getEntry(const Napi::CallbackInfo& info) {
    //ODE_LayerList self;
    //if(!Autobind<ODE_LayerList>::read_into(info[0], self)) { return Napi::Value(); };
    //int i = info[1].As<Napi::Number>().Uint32Value();
    //ODE_ASSERT(i >= 0 && i < self.n);
    //return ode_napi_serialize(info.Env(), self.entries[idx]);
    return Napi::String::New(info.Env(), "TODO");
}
template<>
bool Autobind<ODE_LayerList>::read_into(const Napi::Value& value, ODE_LayerList& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    uintptr_t ptr_entries;
    if(Autobind<uintptr_t>::read_into(obj.Get("entries"), ptr_entries)) {
        parsed.entries = reinterpret_cast<ODE_LayerList::Entry *>(ptr_entries);
    } else {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field entries").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("n"), parsed.n)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field n").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_LayerList& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value entries = ode_napi_serialize(env, (uintptr_t)source.entries);
    if(entries.IsEmpty()) return Napi::Value();
    obj.Set("entries", entries);
    Napi::Value n = ode_napi_serialize(env, source.n);
    if(n.IsEmpty()) return Napi::Value();
    obj.Set("n", n);
    return obj;
}

template<>
bool Autobind<ODE_LayerMetrics>::read_into(const Napi::Value& value, ODE_LayerMetrics& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<ODE_Transformation>::read_into(obj.Get("transformation"), parsed.transformation)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field transformation").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Rectangle>::read_into(obj.Get("logicalBounds"), parsed.logicalBounds)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field logicalBounds").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Rectangle>::read_into(obj.Get("graphicalBounds"), parsed.graphicalBounds)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field graphicalBounds").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<ODE_Rectangle>::read_into(obj.Get("transformedGraphicalBounds"), parsed.transformedGraphicalBounds)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field transformedGraphicalBounds").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_LayerMetrics& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value transformation = ode_napi_serialize(env, source.transformation);
    if(transformation.IsEmpty()) return Napi::Value();
    obj.Set("transformation", transformation);
    Napi::Value logicalBounds = ode_napi_serialize(env, source.logicalBounds);
    if(logicalBounds.IsEmpty()) return Napi::Value();
    obj.Set("logicalBounds", logicalBounds);
    Napi::Value graphicalBounds = ode_napi_serialize(env, source.graphicalBounds);
    if(graphicalBounds.IsEmpty()) return Napi::Value();
    obj.Set("graphicalBounds", graphicalBounds);
    Napi::Value transformedGraphicalBounds = ode_napi_serialize(env, source.transformedGraphicalBounds);
    if(transformedGraphicalBounds.IsEmpty()) return Napi::Value();
    obj.Set("transformedGraphicalBounds", transformedGraphicalBounds);
    return obj;
}

std::string ode_napi_enum_to_string(ODE_ParseError::Type value) {
    switch(value) {
        case ODE_ParseError::OK: return "OK";
        case ODE_ParseError::JSON_SYNTAX_ERROR: return "JSON_SYNTAX_ERROR";
        case ODE_ParseError::UNEXPECTED_END_OF_FILE: return "UNEXPECTED_END_OF_FILE";
        case ODE_ParseError::TYPE_MISMATCH: return "TYPE_MISMATCH";
        case ODE_ParseError::ARRAY_SIZE_MISMATCH: return "ARRAY_SIZE_MISMATCH";
        case ODE_ParseError::UNKNOWN_KEY: return "UNKNOWN_KEY";
        case ODE_ParseError::UNKNOWN_ENUM_VALUE: return "UNKNOWN_ENUM_VALUE";
        case ODE_ParseError::VALUE_OUT_OF_RANGE: return "VALUE_OUT_OF_RANGE";
        case ODE_ParseError::STRING_EXPECTED: return "STRING_EXPECTED";
        case ODE_ParseError::UTF16_ENCODING_ERROR: return "UTF16_ENCODING_ERROR";
        default: return "UNKNOWN_ParseError_Type_"+std::to_string(uint32_t(value));
    }
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_ParseError::Type& source) {
    return Napi::String::New(env, ode_napi_enum_to_string(source));
}

template<>
bool Autobind<ODE_ParseError>::read_into(const Napi::Value& value, ODE_ParseError& parsed){
    Napi::Env env = value.Env();
    Napi::Object obj = value.As<Napi::Object>();
    if(!Autobind<ODE_ParseError::Type>::read_into(obj.Get("type"), parsed.type)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field type").ThrowAsJavaScriptException();
        return false;
    }
    if(!Autobind<int>::read_into(obj.Get("position"), parsed.position)) {
        env.GetAndClearPendingException();
        Napi::Error::New(env, "Invalid value for field position").ThrowAsJavaScriptException();
        return false;
    }
    return true;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_ParseError& source) {
    Napi::Object obj = Napi::Object::New(env);
    Napi::Value type = ode_napi_serialize(env, source.type);
    if(type.IsEmpty()) return Napi::Value();
    obj.Set("type", type);
    Napi::Value position = ode_napi_serialize(env, source.position);
    if(position.IsEmpty()) return Napi::Value();
    obj.Set("position", position);
    return obj;
}

template<>
const char* Handle<ODE_EngineHandle>::name = "EngineHandle";
template<>
bool Autobind<ODE_EngineHandle>::read_into(const Napi::Value& value, ODE_EngineHandle& target) {
    auto optional = Handle<ODE_EngineHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_EngineHandle& source) {
    return Handle<ODE_EngineHandle>::serialize(env, source);
}

template<>
const char* Handle<ODE_DesignHandle>::name = "DesignHandle";
template<>
bool Autobind<ODE_DesignHandle>::read_into(const Napi::Value& value, ODE_DesignHandle& target) {
    auto optional = Handle<ODE_DesignHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_DesignHandle& source) {
    return Handle<ODE_DesignHandle>::serialize(env, source);
}

template<>
const char* Handle<ODE_ComponentHandle>::name = "ComponentHandle";
template<>
bool Autobind<ODE_ComponentHandle>::read_into(const Napi::Value& value, ODE_ComponentHandle& target) {
    auto optional = Handle<ODE_ComponentHandle>::Read(value);
    if(optional) { target = *optional; return true; }
    return false;
}
Napi::Value ode_napi_serialize(Napi::Env env, const ODE_ComponentHandle& source) {
    return Handle<ODE_ComponentHandle>::serialize(env, source);
}

void node_napi_destroyLayerList(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_LayerList layerList;
    if(!Autobind<ODE_LayerList>::read_into(info[0], layerList)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerList ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyLayerList(layerList);
    if(!check_result(env,result)) return;
}

void node_napi_destroyMissingFontList(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_StringList fontList;
    if(!Autobind<ODE_StringList>::read_into(info[0], fontList)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument fontList ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyMissingFontList(fontList);
    if(!check_result(env,result)) return;
}

Napi::Value node_napi_initializeEngineAttributes(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_OUT_RETURN ODE_EngineAttributes engineAttributes;
    auto result = ode_initializeEngineAttributes(&engineAttributes);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, engineAttributes);
}

Napi::Value node_napi_createEngine(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_OUT_RETURN ODE_EngineHandle engine;
    ODE_EngineAttributes engineAttributes;
    if(!Autobind<ODE_EngineAttributes>::read_into(info[0], engineAttributes)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument engineAttributes ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto result = ode_createEngine(&engine, &engineAttributes);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, engine);
}

void node_napi_destroyEngine(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_EngineHandle engine;
    if(!Autobind<ODE_EngineHandle>::read_into(info[0], engine)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument engine ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyEngine(engine);
    if(!check_result(env,result)) return;
}

Napi::Value node_napi_createDesign(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_EngineHandle engine;
    if(!Autobind<ODE_EngineHandle>::read_into(info[0], engine)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument engine ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    ODE_OUT_RETURN ODE_DesignHandle design;
    auto result = ode_createDesign(engine, &design);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, design);
}

void node_napi_loadDesignFromManifestString(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_EngineHandle engine;
    if(!Autobind<ODE_EngineHandle>::read_into(info[0], engine)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument engine ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[1], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef manifestString;
    if(!Autobind<ODE_StringRef>::read_into(info[2], manifestString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument manifestString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_loadDesignFromManifestString(engine, &design, manifestString, &parseError);
    Autobind<ODE_DesignHandle>::write_from(info[1], design);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[3], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_destroyDesign(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_destroyDesign(design);
    if(!check_result(env,result)) return;
}

void node_napi_design_loadManifestString(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef manifestString;
    if(!Autobind<ODE_StringRef>::read_into(info[1], manifestString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument manifestString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_design_loadManifestString(design, manifestString, &parseError);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[2], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_design_addComponentFromOctopusString(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[1], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentMetadata metadata;
    if(!Autobind<ODE_ComponentMetadata>::read_into(info[2], metadata)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument metadata ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef octopusString;
    if(!Autobind<ODE_StringRef>::read_into(info[3], octopusString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument octopusString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_design_addComponentFromOctopusString(design, &component, metadata, octopusString, &parseError);
    Autobind<ODE_ComponentHandle>::write_from(info[1], component);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[4], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_design_removeComponent(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[1], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_design_removeComponent(design, component);
    if(!check_result(env,result)) return;
}

Napi::Value node_napi_design_listMissingFonts(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    ODE_OUT_RETURN ODE_StringList fontList;
    auto result = ode_design_listMissingFonts(design, &fontList);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, fontList);
}

void node_napi_design_loadFontBytes(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef name;
    if(!Autobind<ODE_StringRef>::read_into(info[1], name)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument name ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_MemoryBuffer data;
    if(!Autobind<ODE_MemoryBuffer>::read_into(info[2], data)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument data ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef faceName;
    if(!Autobind<ODE_StringRef>::read_into(info[3], faceName)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument faceName ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_design_loadFontBytes(design, name, &data, faceName);
    Autobind<ODE_MemoryBuffer>::write_from(info[2], data);
    if(!check_result(env,result)) return;
}

void node_napi_design_getComponent(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_DesignHandle design;
    if(!Autobind<ODE_DesignHandle>::read_into(info[0], design)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument design ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[1], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef componentId;
    if(!Autobind<ODE_StringRef>::read_into(info[2], componentId)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument componentId ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_design_getComponent(design, &component, componentId);
    Autobind<ODE_ComponentHandle>::write_from(info[1], component);
    if(!check_result(env,result)) return;
}

void node_napi_component_addLayer(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef parentLayerId;
    if(!Autobind<ODE_StringRef>::read_into(info[1], parentLayerId)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument parentLayerId ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef beforeLayerId;
    if(!Autobind<ODE_StringRef>::read_into(info[2], beforeLayerId)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument beforeLayerId ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef layerOctopusString;
    if(!Autobind<ODE_StringRef>::read_into(info[3], layerOctopusString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerOctopusString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_component_addLayer(component, parentLayerId, beforeLayerId, layerOctopusString, &parseError);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[4], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_component_modifyLayer(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef layerId;
    if(!Autobind<ODE_StringRef>::read_into(info[1], layerId)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerId ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef layerChangeOctopusString;
    if(!Autobind<ODE_StringRef>::read_into(info[2], layerChangeOctopusString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerChangeOctopusString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_component_modifyLayer(component, layerId, layerChangeOctopusString, &parseError);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[3], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_pr1_component_loadAnimation(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef animationDefinition;
    if(!Autobind<ODE_StringRef>::read_into(info[1], animationDefinition)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument animationDefinition ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_ParseError parseError;
    auto result = ode_pr1_component_loadAnimation(component, animationDefinition, &parseError);
    Autobind<ODE_OUT ODE_ParseError>::write_from(info[2], parseError);
    if(!check_result(env,result)) return;
}

void node_napi_pr1_component_getAnimationValueAtTime(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    int index;
    if(!Autobind<int>::read_into(info[1], index)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument index ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_Scalar time;
    if(!Autobind<ODE_Scalar>::read_into(info[2], time)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument time ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_VarDataPtr value;
    if(!Autobind<ODE_VarDataPtr>::read_into(info[3], value)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument value ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_pr1_component_getAnimationValueAtTime(component, index, time, value);
    if(!check_result(env,result)) return;
}

Napi::Value node_napi_component_listLayers(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    ODE_OUT_RETURN ODE_LayerList layerList;
    auto result = ode_component_listLayers(component, &layerList);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, layerList);
}

void node_napi_component_identifyLayer(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_OUT ODE_String layerId;
    ODE_Vector2 position;
    if(!Autobind<ODE_Vector2>::read_into(info[2], position)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument position ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_Scalar radius;
    if(!Autobind<ODE_Scalar>::read_into(info[3], radius)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument radius ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_component_identifyLayer(component, &layerId, position, radius);
    Autobind<ODE_OUT ODE_String>::write_from(info[1], layerId);
    if(!check_result(env,result)) return;
}

void node_napi_component_getLayerMetrics(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_StringRef layerId;
    if(!Autobind<ODE_StringRef>::read_into(info[1], layerId)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerId ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_LayerMetrics layerMetrics;
    if(!Autobind<ODE_LayerMetrics>::read_into(info[2], layerMetrics)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument layerMetrics ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_component_getLayerMetrics(component, layerId, &layerMetrics);
    Autobind<ODE_LayerMetrics>::write_from(info[2], layerMetrics);
    if(!check_result(env,result)) return;
}

Napi::Value node_napi_component_listMissingFonts(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    ODE_OUT_RETURN ODE_StringList fontList;
    auto result = ode_component_listMissingFonts(component, &fontList);
    if(!check_result(env,result)) return Napi::Value();
    return ode_napi_serialize(env, fontList);
}

void node_napi_component_getOctopus(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ODE_ComponentHandle component;
    if(!Autobind<ODE_ComponentHandle>::read_into(info[0], component)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument component ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    ODE_String octopusString;
    if(!Autobind<ODE_String>::read_into(info[1], octopusString)) {
        auto ex = env.GetAndClearPendingException();
        Napi::Error::New(env, "Failed to parse argument octopusString ("+ ex.Message() +")").ThrowAsJavaScriptException();
        return;
    }
    auto result = ode_component_getOctopus(component, &octopusString);
    Autobind<ODE_String>::write_from(info[1], octopusString);
    if(!check_result(env,result)) return;
}

